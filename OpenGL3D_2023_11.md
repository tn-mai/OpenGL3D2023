[OpenGL 3D 2023 第11回]

# 3Dモデル アセットと音声

## 習得目標

* ダウンロードしたアセットをOBJファイルに変換できる
* 半透明モデルを不透明モデルの後に描画しなくてはならない理由を説明できる
* データ(マップ)ファイルに独自の機能を追加することができる
* C++の乱数生成クラスの使い方を説明できる
* 音声再生ライブラリを追加し、音声を再生することができる

## 1. UnityのアセットをOBJファイルにする

### 1.1 アセットストアのアセットからOBJファイル作る方法

3Dゲームを作成するときの大きな問題は

>どうやって3Dモデルやテクスチャを用意するか

ということです。この問題を比較的簡単に解決する手段として、「ゲームエンジンのアセットストアを利用する」という方法があります。

例えば、Unityアセットストアにあるアセットには、Unity以外のアプリケーションでも利用可能とされているものがあります。

例えば、標準的なUnityAssetStoreライセンスのものは利用可能です。フリーか有料かを問わず、ほとんどのアセットがこのライセンスを使っているので、かなり選択の幅が広がります。

また、Unreal Engineの標準ライセンスも同様の利用規約になっています。つまり、UnityとUnreal Engineのアセットストアにある大量のアセットが利用できるわけです。

ただ、UnityにもUnreal Engineにも、OBJファイルを出力する機能がありません。そこで、以下のような方法でアセットからOBJファイルやTGAファイルを作成する必要があります。

>1. アセットフォルダにあるFBXとテクスチャをVisual Studioで開き、OBJファイルとTGAファイルとして保存する。
>2. 各エンジンのアセットストアから、OBJ変換アセット(UnityならScene OBJ Exporterなど)をインストールして変換する。
>3. アセットフォルダにあるFBXとテクスチャをBlenderなどのツールにインポートし、OBJファイルとしてエクスポートする。

`1`の方法は、Visual Studioがインストール済みなら手軽に試せます。ただし、多くのアセットを変換するには少し手間がかかります。ひとつひとつファイルを開いて変換を繰り返す必要があるからです。

`2`の方法はインストールの手間があるものの、いちばんのお勧めです。アセットストアにあるアセットは、対応するエンジンであればまず間違いなく読み込めるからです。アセットによってはまとめて変換する機能があり、変換の手間を減らせます。

`3`はアセットを修正したり、アセットの一部分を取り出して使いたい場合に便利です。ただし、FBXファイルには多くのバージョンがあるため、ツールによっては一部のバージョンしか対応していないことがあります。インポートできない場合は、他のツールを試してみてください。

本テキストでは、「無料のOBJ変換アセットがある」という点を考慮して、Unityを使ってアセットを取り込むことにします。Unreal EngineのOBJエクスポートはポリゴンのみで、マテリアルに対応するには有料アセットが必要です。

### 1.2 Scene OBJ Exporterアセット

Unityには標準でOBJファイルを出力する機能がありません。ですから、まずはOBJファイルを出力する方法を追加する必要があります。

OBJ出力機能を追加するにはいくつかの方法がありますが、今回はアセットストアにある「Scene OBJ Exporter(シーン・オブジェ・エクスポーター)」を使おうと思います。

「Unity Asset Store」のサイトを開き、上部の検索ボックスに「scene obj exporter」と入力すると、次のようにアセットがひとつ見つかります。

<p align="center">
<img src="images/11_scene_obj_exporter_on_asset_store_0.png" width="80%" />
</p>

このアセットをクリックすると、Scene OBJ Exporterアセットのページが開きます。

<p align="center">
<img src="images/11_scene_obj_exporter_on_asset_store.png" width="75%" />
</p>

ページが開いたら、「マイアセットに追加する」をクリックしてアセットを追加してください。

次に、新しいプロジェクトを作成してUnityエディタを起動します。そして、メニューから「Edit -> Package Manager」を選択してパッケージマネージャを起動してください。

「Packages」の部分をクリックして「My Assets」を選択すると、リストに「Scene OBJ Exporter」が表示されると思います。

「Scene OBJ Exporter」をクリックするとアセットの詳細が表示されるので、右下の「download」ボタンをクリックしてアセットをダウンロードしてください。

<p align="center">
<img src="images/11_scene_obj_exporter_on_package_manager.png" width="80%" />
</p>

ダウンロードが終わるとボタンが「Import」に変化します。「Import」ボタンを押すと「Import Unity Package」ウィンドウが開きます。

<p align="center">
<img src="images/11_scene_obj_exporter_on_import_window.png" width="40%" />
</p>

右下の「Import」ボタンを押してしばらく待つと、プロジェクトに「Scene OBJ Exporter」がインポート(追加)されます。アップデートを促すダイアログが表示された場合は、左側の`Yes, for these and ...`と書かれたボタンをクリックして、APIをアップデートしてください。

<p align="center">
<img src="images/11_scene_obj_exporter_api_update_dialog.png" width="50%" />
</p>

インポートが完了したら、左上の「File」メニューをクリックしてください。メニューの一番下に「Export」という項目が追加されていたら、「Scene OBJ Exporter」のインポートは成功です。表示されない場合は、新規プロジェクトの作成からやりなおしてみてください。

<p align="center">
<img src="images/11_scene_obj_exporter_menu_item.png" width="40%" />
</p>

### 1.3 アセットを追加する

それでは、適当なアセットから「壁」のOBJファイルを作成してみましょう。Webブラウザで`Unity Asset Store`を開き、`Hospital Horror Pack`というアセットを検索し、「マイアセットに追加」してください。

<p align="center">
<img src="images/11_horror_hospital_pack_on_asset_store.jpg" width="40%" />
</p>

<pre class="tnmai_assignment">
<strong>【課題01】</strong>
<code>Horror Hospital Pack</code>アセットを、Scene OBJ Exporterと同じプロジェクトにインポートしなさい。インポートの必要があるのは3Dモデルとテクスチャだけです。
以下のように<code>Horror Hospital Pakc</code>にだけチェックを入れて(他はすべてチェックを外して)インポートするとよいでしょう。
<img src="images/11_horror_hospital_pack_import_settings.jpg" width="40%" />
</pre>

さて、`Hospital Horror Pack`に含まれる壁モデルは片面だけのモデルなので、そのままでは壁ブロックとしては使えません。そこで、ブロックを囲むように四つの壁モデルを配置することにします。

とりあえず、`Wall`プレハブをシーンにドラッグ&ドロップしてください。

<p align="center">
<img src="images/11_add_wall_prefab.jpg" width="66%" />
</p>

次に、`Wall`オブジェクトを迷路のブロックサイズに合わせます。迷路のブロックサイズは2x2mなので、横幅が約2mになるようにスケールを調整します。

いくつかの数値を試した結果、スケールを`(0.375, 0.725, 0.725)`に設定すると約2mになることが分かりました。ゲームオブジェクトのスケールにこの数値を設定してください。

<p align="center">
<img src="images/11_wall_scalling.jpg" width="50%" />
</p>

次に、この`Wall`オブジェクトをブロックの4面に配置します。最初の`Wall`オブジェクトは-X方向を向いているので、-X側の壁にします。ゲームオブジェクトのポジションを`(-1, 1, 0)`に設定してください。

<p align="center">
<img src="images/11_wall_position.jpg" width="50%" />
</p>

続いて+Z側の壁を作成します。シーンに配置されている`Wall`オブジェクトを選択し、`Ctrl+C`, `Ctrl+V`でオブジェクトをコピーします。

次に、コピーで作られた`Wall (1)`オブジェクトのポジションとローテーションの値を、以下の画像のように変更してください。

<p align="center">
<img src="images/11_wall_second.jpg" width="50%" />
</p>

<pre class="tnmai_assignment">
<strong>【課題02】</strong>
<code>Wall</code>オブジェクトをコピー&ペーストして、+X方向の壁と-Z方向の壁を追加しなさい。外側から見たときに、壁の画像が表示されるようにすること。
</pre>

<div style="page-break-after: always"></div>

### 1.4 ブロックの角を埋める

これで、壁をブロック状に配置することができました。上下の部分は空洞ですが、迷路内からは見えない部分なのでそのままにします。

ただ、ブロックの角の部分に近寄ると、壁の下部にある「巾木(はばき)」や上部にある「廻り縁(まわりぶち)」、それと「腰壁(こしかべ、)」の上部などに、隙間が開いていることに気が付きます。

>腰壁(こしかべ)は「腰の高さより下に張りめぐらせる、素材や仕上げの異なる部分」のことです。

この隙間を埋めるために、`Wall2`プレハブを使うことにします。`Wall2`プレハブをシーンにドラッグ&ドロップしてください。

<p align="center">
<img src="images/11_add_wall2_prefab.jpg" width="66%" />
</p>

次に、`Wall2`オブジェクトのポジション、ローテーション、スケールを変更して、ブロックの角に配置します。

`Wall2`オブジェクトのポジションを`(-1, 1, -1)`、スケールを`(0.2, 0.725, 0.2)`に設定してください。

<p align="center">
<img src="images/11_wall2_transform.jpg" width="50%" />
</p>

`Wall2`プレハブは円柱を半分にした形状なので、円柱状にするためにもうひとつの`Wall2`プレハブを追加し、180度回転させます。`Wall2`オブジェクトを選択して`Ctrl+C`, `Ctrl+V`
でオブジェクトをコピーしてください。

次に、コピーした`Wall2 (1)`オブジェクトのローテションを`(0, 0, 0)`に設定してください。

<p align="center">
<img src="images/11_wall2_transform_1.jpg" width="50%" />
</p>

これで角のひとつをごまかすことができました。

<pre class="tnmai_assignment">
<strong>【課題03】</strong>
<code>Wall2</code>および<code>Wall2 (1)</code>オブジェクトをコピー&ペーストして、残りの3つの角の隙間を埋めなさい。
</pre>

これで、壁用のモデルが完成しました。

>**【出来の良いアセットの場合】**<br>
>直角に並べても角に隙間ができないよう、上手に作られているアセットの場合は、角を埋めるような操作は不要です。

### 1.5 アセットをOBJファイルとして出力する

ゲームオブジェクトからOBUファイルを作成するには、シーン内にある「OBJファイルにしたいゲームオブジェクト」だけを選択状態にします。

ゲームオブジェクトに親子関係がある場合、すべての子ゲームオブジェクトを選択する必要があるので注意してください。マウスドラッグですべてのオブジェクトを囲むように選択すると簡単です。

>**【Prefabを使う場合】**<br>
>Prefabモデルの場合はヒエラルキーツリーを展開して、Prefabに含まれる全てのモデルを選択してください。

<p align="center">
<img src="images/11_select_all_objects.png" width="33%" />
</p>

出力したいオブジェクト選択したら、メニューの「File -> Export -> Wavefront OBJ」をクリックしてください。

<p align="center">
<img src="images/11_scene_obj_exporter_menu_item.png" width="50%" />
</p>

すると「Export OBJ」ウィンドウが開きます。以下の手順でチェックボックスを設定し、エクスポートしてください。

>1. `Only Selected Objects`(オンリー・セレクテッド・オブジェクツ)にチェックを入れる(入れないとシーン全体が出力される)。
>2. `Auto Mark Tex Readable`(オート・マーク・テックス・リーダブル)にチェックを入れる(入れないとテクスチャが出力されない)。
>3. `Export`(エクスポート)ボタンをクリック。

<p align="center">
<img src="images/11_scene_obj_exporter_export_settings.png" width="33%" />
</p>

すると、次のような警告ウィンドウが開きます。

<p align="center">
<img src="images/11_scene_obj_exporter_warning.png" width="40%" />
</p>

<div style="page-break-after: always"></div>

このウィンドウは`Auto Mark Tex Readable`にチェックを入れると表示されるもので、

>アセットのテクスチャの読み書きを可能にするよ。この変更を簡単に元に戻す方法はないよ。続けてもいいかい？

ということを聞いてきています。とはいえ、これは念のための警告で、基本的に実害はないので`Yes`を選択してください。すると、出力ファイル名を指定するウィンドウが開きます。

さて、今後さまざまなアセットからOBJファイルを作成することになりますが、そうすると、どのアセットから作成したのか分からなくなることが多いです。そこで、アセットごとにフォルダを分けることをおすすめします。

以下の手順にしたがって、作成したブロックをエクスポートしてください。

1. ExportウィンドウでOpenGLプロジェクトの`Res/MeshData`フォルダを選択。
2. Exportウィンドウの左上にある「新しいフォルダー」ボタンをクリックして、`Res/MeshData`フォルダに`HorrorHospitalPack`という名前のフォルダを作成。
3. 作成した`HorrorHospitalPack`フォルダをダブルクリックしてフォルダ内に移動。
4. ファイル名を`Wall.obj`に変更。
5. 「保存(S)」ボタンをクリック。

<p align="center">
<img src="images/11_scene_obj_exporter_export_window.png" width="50%" />
</p>

これで、アセットからOBJファイルを作成することができました。

>**【その他の注意点】**<br>
>ゲームオブジェクトに `Mesh Renderer`コンポーネントが設定されている必要があります。また、`Skinned Mesh Renderer`には対応していません。ただし、`Skinned Mesh Renderer`から`Mesh Renderer`に変換するアセットを使えば、間接的に変換することは可能です。

>**【常に原点に配置するUnityのオプション】**<br>
>Unityエディタの「Preferences → Scene View → General」にある`Create Objects at Origin`項目にチェックを入れると、ドラッグ&ドロップで追加したオブジェクトが常に原点に配置されるようになります。この機能はUnity 2020 LST以降で利用可能です。

<div style="page-break-after: always"></div>

### 1.6 MTLファイルを修正する

Scene OBJ Exporterは、OBJファイルに加えてMTLファイルもエクスポートしてくれます。ただし、テクスチャファイルが絶対パスで指定されているため、そのままでは正しく読み込むことができません。

そこで、MTLファイルを修正します。OpenGLプロジェクトの`Res/MeshData/HorrorHospitalPack`フォルダを開き、`Wall.mtl`ファイルをVisual Studioにドラッグ&ドロップしてください(メモ帳で開いても構いません)。<br>
すると、以下のような内容になっていると思います。

```txt
newmtl WallDiffuse
Kd 1 1 1
map_Kd C:/OpenGL2023/Res/MeshData/HorrorHospitalPack/WallDiffuse.png
map_Bump C:/OpenGL2023/Res/MeshData/HorrorHospitalPack/WallNormal.png
illum 2
```

このように、2つのテクスチャファイル名が`C:/`から始まる絶対パスになっています。

現在のプログラムは相対パスにしか対応していません。そこで、ファイル名の前にあるファルダ名はすべて削除して、相対パスに変換してください。

```diff
 newmtl WallDiffuse
 Kd 1 1 1
-map_Kd C:/OpenGL2023/Res/MeshData/HorrorHospitalPack/WallDiffuse.png
-map_Bump C:/OpenGL2023/Res/MeshData/HorrorHospitalPack/WallNormal.png
+map_Kd WallDiffuse.png
+map_Bump WallNormal.png
 illum 2
```

それから、PNG形式には未対応なので拡張子を`tga`に変換してください。

```diff
 newmtl WallDiffuse
 Kd 1 1 1
-map_Kd WallDiffuse.png
-map_Bump WallNormal.png
+map_Kd WallDiffuse.tga
+map_Bump WallNormal.tga
 illum 2
```

<pre class="tnmai_assignment">
<strong>【課題04】</strong>
<code>WallDiffuse.png</code>と<code>WallNormal.png</code>をTGAファイルに変換しなさい。変換が済んだらPNGファイルは削除しておくこと。
(WallNormal.tgaは今はまだ必要ありません。ですが、そのうち使うので忘れないうちに変換しておきます)。
</pre>

### 1.7 エクスポートしたOBJファイルを表示する

それでは、エクスポートした`Wall.obj`を表示してみましょう。`Engine.cpp`を開き、
`Initialize`メンバ関数にあるメッシュを追加するプログラムに、次のプログラムを追加してください。

```diff
   meshBuffer->LoadOBJ("Res/MeshData/door/arch.obj");
   meshBuffer->LoadOBJ("Res/MeshData/lever/lever_arm.obj");
   meshBuffer->LoadOBJ("Res/MeshData/lever/lever_cover.obj");
+  meshBuffer->LoadOBJ("Res/MeshData/HorrorHospitalPack/Wall.obj");

   // ゲームオブジェクト配列の容量を予約
   gameObjects.reserve(1000);
```

次に、`MainGameScene.cpp`を開き、`Initialize`メンバ関数にある壁を作成するプログラムを次のように変更してください。

```diff
         auto wall = engine.Create<GameObject>(
           "wall", { posX, 0, posZ });
         wall->scale = { squareScale, squareScale, squareScale };
-        wall->texColor = texWall;
-        wall->meshId = MeshId_wall;
+        wall->staticMesh = engine.GetStaticMesh(
+          "Res/MeshData/HorrorHospitalPack/Wall.obj");
       }
       // ドアを設定
       else if (tileId == '|' || tileId == '-') {
```

プログラムがけたらビルドして実行してください。薄汚れた病院の壁が表示されていたら成功です。

<p align="center">
<img src="images/11_result_0.jpg" width="45%" />
</p>

このように、どんな方法でもいいのでとにかくOBJファイルに変換できれば、ゲームに登場させることができます。

### 1.8 Scene OBJ Exporterを改造する

Scene OBJ Exporterが出力する画像ファイルはPNG形式なので、Visual Studio等でTGA形式に変換する必要があります。また、MTLファイルに絶対パスが書き込まれるため、いちいち相対パスに書き換えなくてはなりません。

このような作業を毎回行うのは面倒です。そこで、Scene OBJ Exporterを改造して、直接TGAファイルが出力されるようにしましょう。

目的のスクリプトはUnityプロジェクトの`Assets/OBJExport`フォルダにあります。エクスプローラなどでUnityプロジェクトの`Assets/OBJExport`フォルダを開き、`OBJExporter.cs`
というC#ファイルをVisual Studioにドラッグ&ドロップして開いてください。

変更する場所は`OBJExporter.cs`の329～332行目のあたりです。この部分はテクスチャを変換してエクスポートするプログラムになっています。

それでは、テクスチャをエクスポートするプログラムを次のように変更してください。

```diff
           }
       }
-      string exportName = lastExportFolder + "\\" + t.name + ".png";
+      string exportName = lastExportFolder + "\\" + t.name + ".tga";
       Texture2D exTexture = new Texture2D(t.width, t.height, TextureFormat.ARGB32, false);
       exTexture.SetPixels(t.GetPixels());
-      System.IO.File.WriteAllBytes(exportName, exTexture.EncodeToPNG());
-      return exportName;
+      System.IO.File.WriteAllBytes(exportName, exTexture.EncodeToTGA());
+      return t.name + ".tga";
   }
```

UnityにはTGAに変換する関数も用意されているため、ファイルの拡張子と変換関数を変えるだけでTGAに対応できます。

また、`exportName`変数には絶対パスが格納されているため、これを戻り値にしてしまうとMTLファイルにも絶対パスが書き込まれてしまいます。そこで、戻り値を`t.name + ".tga"`に変更することで、MTLファイルにファイル名だけが出力されるようにしています。

これで、いちいちMTLファイルを編集したりPNGファイルをTGAファイルに変換する必要はなくなりました。

>**【適切なサイズのテクスチャを使う】**<br>
>特にリアル系のアセットに多いのですが、テクスチャサイズが必要以上に大きく、無圧縮TGAに変換するとファイルサイズが非常に大きくなってしまうことがあります。就職作品として提出するZIPファイルのサイズに影響するので、ファイルサイズはあまり大きくしないほうが安全です。目安として、1024x1024を超えるテクスチャは大きすぎます。目安を超えるテクスチャを見つけた場合は、手動で縮小するとよいでしょう。

### 1.9 床(ゆか)のOBJファイルを作成する

`Horror Hospital Pack`には床や天井のモデルは存在しませんが、床と天井用のマテリアルは用意されています。このような場合、Unityではメニューから

`GameObject -> 3D Object -> Quad`

を選択することで1x1mの平面を作成できるので、これを利用します(`Plane`は10x10mなので大きすぎます)。

`GameObject -> 3D Object -> Quad`を選択して、シーンに`Quad`(クアッド)オブジェクトを追加してください。

>**【ゲームオブジェクトを非表示にする】**<br>
>`Wall`オブジェクトが邪魔で`Quad`が見にくい場合、ヒエラルキーウィンドウのゲームオブジェクトの左にある「眼」のアイコンをクリックして、`Wall`オブジェクトを一時的に見えなくするとよいでしょう。

追加すると分かりますが、`Quad`はXY平面として定義されています。このままでは壁になってしまうので、X軸を90度回転させてXZ平面にします(Z軸でもOK)。それから、ポジションを`(-0.5, 0, -0.5)`に設定します。

<p align="center">
<img src="images/11_quad_transform.jpg" width="50%" />
</p>

次に、アセットの`Material/Floor`フォルダにある`mFloor`というマテリアルを、`Quad`オブジェクトにドラッグ&ドロップしてください。

<p align="center">
<img src="images/11_set_floor_material.jpg" width="50%" />
</p>

<pre class="tnmai_assignment">
<strong>【課題05】</strong>
<code>Quad</code>オブジェクトを3回コピー&ペーストして、以下の3つのポジションに配置しなさい。
( 0.5, 0, -0.5)
(-0.5, 0,  0.5)
( 0.5, 0,  0.5)
</pre>

これで床モデルは完成です。4つの`Quad`オブジェクトをすべて選択し、メニューから

`File -> Export -> Wavefront OBJ`

を選択してエクスポートしてください。ファイル名は`Floor.obj`としてください。

### 1.10 床を表示する

作成した床(ゆか)のOBJファイルをゲームで表示してみましょう。まずOBJファイルを読み込みます。`Engine.cpp`を開き、`Initialize`メンバ関数にあるOBJファイルを読み込むプログラムに、次のプログラムを追加してください。

```diff
   meshBuffer->LoadOBJ("Res/MeshData/lever/lever_arm.obj");
   meshBuffer->LoadOBJ("Res/MeshData/lever/lever_cover.obj");
   meshBuffer->LoadOBJ("Res/MeshData/HorrorHospitalPack/Wall.obj");
+  meshBuffer->LoadOBJ("Res/MeshData/HorrorHospitalPack/Floor.obj");

   // ゲームオブジェクト配列の容量を予約
   gameObjects.reserve(1000);
```

次に`MainGameScene.cpp`を開き、床を作成するプログラムを次のように変更してください。

```diff
   } // while

   // 床を作成
-  auto floor = engine.Create<GameObject>("floor");
-  floor->scale = {
-    static_cast<float>(mapSizeX) * squareScale, 1,
-    static_cast<float>(mapSizeY) * squareScale };
-  floor->position = { floor->scale.x, -1, floor->scale.z };
-  floor->texColor = std::make_shared<Texture>("Res/floor.tga");
-  floor->meshId = MeshId_box;
+  const auto meshFloor = engine.GetStaticMesh(
+    "Res/MeshData/HorrorHospitalPack/Floor.obj");
+  for (int y = 0; y < mapSizeY; ++y) {
+    for (int x = 0; x < mapSizeX; ++x) {
+      const float posX = static_cast<float>(x + 0.5) * squareSize;
+      const float posZ = static_cast<float>(y + 0.5) * squareSize;
+
+      auto floor = engine.Create<GameObject>("floor");
+      floor->position = { posX, 0, posZ };
+      floor->staticMesh = meshFloor;
+    } // for x
+  } // for y

   // プレイヤーのスタート地点
   vec3 startPoint = { 3, 1.2f, 3 };
```

プログラムが書けたらビルドして実行してください。足元に「病院の床」が表示されていたら成功です。

<p align="center">
<img src="images/11_result_1.jpg" width="45%" />
</p>

<pre class="tnmai_assignment">
<strong>【課題06】</strong>
床と同じ方法で「天井」のOBJファイルを作成し、ゲーム画面に表示しなさい。
</pre>

<pre class="tnmai_assignment">
<strong>【課題07】</strong>
壁と床の作成方法を参考にして「ドア」のOBJファイルを作成し、現在ゲーム中で使われている「石のアーチ」と「木のドア」を、作成したOBJファイルで置き換えなさい。
</pre>

>**【1章のまとめ】**
>
>* アセットをOBJ形式に変換するには、OBJ変換アセットを使うか、Blender, Visual Studio等にFBXを読み込んで変換する。
>* アセットに望みの図形が含まれない場合でも、Unity上で大きさや形状を整えたり、複数のアセットをうまく組み合わせれば、望みの図形を作り出すことができる。
>* スクリプトを改造することで、変換の手間を減らせる場合がある。

<div style="page-break-after: always"></div>

## 2. 半透明なモデルの描画方法

### 2.1 マップファイルに蛍光灯を追加する

壁と床と天井だけではいかにも殺風景なので、天井に蛍光灯を配置してみましょう。

Unityエディタで`Horror Hospital Pack`に含まれる`Lamp`(ランプ)プレハブを選んで、シーンにドラッグ&ドロップしてください。

`Lamp`プレハブを配置したら、ポジションを`(0.0, 0.6, 0.0)`に設定してください。

<p align="center">
<img src="images/11_lamp_transform.jpg" width="60%" />
</p>

<pre class="tnmai_assignment">
<strong>【課題08】</strong>
LampアセットをOBJファイルに変換し、<code>Lamp.obj</code>という名前でプロジェクトの<code>Res/MeshData/HorrorHospitalPack</code>フォルダに保存しなさい。
保存したら、<code>Engine::Initialize</code>メンバ関数に、<code>Lamp.obj</code>を読み込むプログラムを追加しなさい。
</pre>

配置したら、`Scene OBJ Exporter`を使ってOBJファイルに変換し、プロジェクトの`Res/MeshData/HorrorHospitalPack`フォルダに保存してください。ファイル名は`Lamp.obj`としてください。

蛍光灯の位置は`maze00.txt`に記述(きじゅつ)します。`maze00.txt`を開き、次のテキストを追加してください。

```diff
 // タイプ		名前	X座標	Y座標	Y角度	起動対象のオブジェクト名
 lever			lever0	3		2		0
 remote_door	door0	2		3		180		lever0
+ライト			蛍光灯	2		2		0
+ライト			蛍光灯	3		4		90
+ライト			蛍光灯	2.5		6.5		90
+ライト			蛍光灯	3.5		6.5		0
```

#### 【マップファイルはUTF-8(ユーティーエフ・はち)で保存すること】

この例のように、マップファイルには日本語を使うこともできます。ただし、ファイルを保存するときに、文字コードを`UTF-8`にして保存してください。

「メモ帳」の場合は「ファイル→名前を指定して保存」を選びます。すると、ウィンドウ下部に文字コードを選択する領域が表示されるので、「UTF-8」を選びます。よく似た「UTF-8(BOT付き)」もありますが、これは選ばないように注意してください。

Visual Studioの場合は「名前を付けてmaze00.txtを保存」を選び、「上書き保存の右にある三角アイコン」をクリックします。そして「エンコード付きで保存」を選び、エンコードとして「UTF-8 シグネチャなし」を選んで保存します。

同じ単語や文章でも、文字コードが異なると、全く異なる数値としてデータ化されます。例えば「蛍光灯」という文字列は、今回使用する`UTF-8`と、Visual Studioの標準の文字コードである`CP932`では以下のように異なる数値に変換されます。

>蛍光灯 → UTF-8でデータ化 → 232, 155, 141, 229, 133, 137, 231, 129, 175<br>
>蛍光灯 → CP932でデータ化 → 140, 117, 140, 245, 147, 148

このように、文字コードごとにデータ化された数値が大きく異なることが分かると思います。なお、マップファイルの文字コードにUTF-8を選んだ理由は、2023年現在において「UTF-8が世界的に標準の文字コードになっているから」です。

### 2.2 蛍光灯コンポーネントを定義する

次に、マップファイルから「蛍光灯のデータ」を読み取って、`Lamp.obj`を表示するプログラムを作成しましょう。まず「蛍光灯コンポーネント」を作成します。

蛍光灯は`Fluorescent Light`(フルーレセント・ライト)というので、コンポーネント名も`FluorescentLight`とします。見慣れない単語なのでタイプしにくいと思いますが、下手に別の名前を付けて分かりにくくなるよりはいいでしょう。

プロジェクトの`Src`フォルダに`FluorescentLight.h`という名前のヘッダファイルを追加してください。追加したファイルを開き、次のプログラムを追加してください。

```diff
+/**
+* @file FluoresentLight.h
+*/
+#ifndef FLUORESCENTLIGHT_H_INCLUDED
+#define FLUORESCENTLIGHT_H_INCLUDED
+#include "Engine/Component.h"
+#include "Engine/Engine.h"
+
+/**
+* 蛍光灯(フルーレセント・ライト)コンポーネント
+*/
+class FluorescentLight : public Component
+{
+public:
+  FluorescentLight() = default;
+  virtual ~FluorescentLight() = default;
+
+  // ゲームオブジェクトに追加された時に呼び出される
+  virtual void Awake() override
+  {
+    // 蛍光灯モデルを設定
+    auto owner = GetOwner();
+    auto engine = owner->GetEngine();
+    owner->staticMesh = engine->GetStaticMesh(
+      "Res/MeshData/HorrorHospitalPack/Lamp.obj");
+  }
+};
+
+#endif // FLUORESCENTLIGHT_H_INCLUDED
```

作成した「フルーレセント・ライト」コンポーネントを使って、蛍光灯を表示しましょう。
`MainGameScene.cpp`を開き、`FluorescentLight.h`をインクルードしてください。

```diff
 #include "SimpleLever.h"
 #include "RemoteDoor.h"
 #include "EnemySkull.h"
+#include "FluorescentLight.h"
 #include "TitleScene.h"
 #include "Engine/UIButton.h"
```

次に`Initialize`メンバ関数に次のプログラムを追加してください。

```diff
         linkedObject->AddRemoteObject(component);
       }
       mapObjects.push_back(component);
     }
+    // ライトを作成
+    else if (strcmp(type, u8"ライト") == 0) {
+      // 蛍光灯を作成
+      if (strcmp(name, u8"蛍光灯") == 0) {
+        pos.y = 1.75f; // 蛍光灯がいいかんじの位置に表示されるように調整
+        auto light = engine.Create<GameObject>(name, pos, { 0, rotY, 0 });
+        light->AddComponent<FluorescentLight>();
+      } // if 蛍光灯
+    }
   } // while

   // 床を作成
```

文字列の前にある`u8`(ユー・はち)は、「文字列をUTF-8としてデータ化(エンコード)する」ことを指示する「プレフィックス(「接頭辞(せっとうじ)」という意味)」です。

`u8`を付けない場合、ビルドシステムに設定された文字列が使われます。Visual Studioの標準の文字コードは`CP932`(シーピー・きゅうさんに)です。`CP932`は日本で広く使われている
`Shift-JIS`(シフト・ジス)という文字コードに、いくつかの文字を追加したものです。

>**【`Shift-JIS`と`CP932`について】**<br>
>詳しくは以下のURLを参照してください。
>
>CP932とMS932の違いを調べて知ったCP932とSJISの違い:<br>
>`https://ponsuke-tarou.hatenablog.com/entry/2020/10/08/002458`

前に説明したように、同じ文字列であっても文字コードが異なると数値が異なります。文字列の比較は、実際には「同じ数値かどうか」を見ているだけなので、文字コードが異なると正しい比較は行えません。

今回の場合、マップファイルは`UTF-8`でエンコードされています。そのため、比較する文字列も`UTF-8`でエンコードしなくてはならないわけです。C++20において、文字コードを指定するプレフィックスには以下の4種類が定義されています。

| プレフィックス | エンコード | 文字の型 |
|:--:|:---|:--:|
| (なし) | (実装依存)<br>日本語WindowsではCP932 | char |
| u8 | UTF-8 | char(C++17まで), char8_t(C++20以降) |
| L  | (実装依存)WindowsではUTF-16 | wchar_t |
| u  | UTF-16 | char16_t |
| U  | UTF-32 | char32_t |

プログラムが書けたらビルドして実行してください。蛍光灯が表示されていたら成功です。

<p align="center">
<img src="images/11_result_2.jpg" width="45%" />
</p>

### 2.3 ビルボードを追加する

3Dモデルを配置しただけだと「光源らしさ」が足りないように思えます。そこで、ビルボードを配置して「空気中のホコリなどによって、光源付近がぼんやりと明るくなる」表現を追加します。とりあえず、適当な画像を用意しましょう。

<pre class="tnmai_assignment">
<strong>【課題09】</strong>
以下のURLから<code>glare.png</code>(グレア)画像をダウンロードし、TGA形式に変換して、プロジェクトの<code>Res</code>フォルダに保存しなさい。
`https://github.com/tn-mai/OpenGL3D2023/blob/main/res/glare.png`
</pre>

次に`FluorescentLight.h`を開き、`Billboard.h`をインクルードしてください。

```diff
 #ifndef FLUORESCENTLIGHT_H_INCLUDED
 #define FLUORESCENTLIGHT_H_INCLUDED
 #include "Engine/Component.h"
+#include "Engine/Billboard.h"
 #include "Engine/Engine.h"

 /**
 * 蛍光灯(フルーレセント・ライト)コンポーネント
```

続いて、`Awake`メンバ関数の定義に次のプログラムを追加してください。

```diff
     auto engine = owner->GetEngine();
     owner->staticMesh = engine->GetStaticMesh(
       "Res/MeshData/HorrorHospitalPack/Lamp.obj");
+
+    // ぼんやりとした光を追加
+    auto glare = engine->Create<GameObject>("glare", owner->position);
+    glare->position.y -= 0.25f; // いいかんじ見えるように位置を調整
+    glare->meshId = MeshId_plane_xy;
+    glare->texColor = std::make_shared<Texture>("Res/glare.tga");
+    glare->AddComponent<Billboard>();
   }
 };
```

プログラムが書けたらビルドして実行してください。次のように、なんだかおかしな表示になっていたら成功です。

<p align="center">
<img src="images/11_result_3.jpg" width="45%" />
</p>

### 2.5 レンダーキューに半透明モデル用のキューを追加する

一部が透けたような、おかしな表示になるのは「深度バッファ」と「深度テスト」の影響です。ポリゴンを描画すると、たとえそのポリゴンが完全に透明であっても、カラーバッファと深度バッファへの書き込みが行われます。

深度バッファの値が「透明な壁のある位置」に設定されるため、以後の描画では「透明な壁」より奥にあるピクセルは深度テストに失敗します。結果として、そのピクセルは描画されなくなるわけです。

以下は深度バッファを可視化したものです。カラーバッファで不自然に見える領域が、深度バッファでも四角い灰色で見えていることが分かります。

<p align="center">
<img src="images/11_result_3_color_buffer.jpg" width="45%"/>&emsp;<img src="images/11_result_3_depth_buffer.png" width="45%"/><br>
[左=カラーバッファ 右=深度バッファ]
</p>

このような「意図しない深度テストの失敗」を防ぐ方法としては、以下の2種類が考えられます。

>1. カメラから遠いゲームオブジェクトほど先に描画されるようにする。
>2. 先に完全に不透明なモデルを描画し、その後で半透明な部分を持つモデルを描画する。

どちらの方法も「描画順を制御することで問題を回避しようとする」点は共通です。しかし、処理にかかる時間では大きな違いがあります。

方法`1`では、すべてのオブジェクトについて「カメラからの距離」を計算しなくてはなりません。それに対して方法`2`では、事前に半透明かどうかを設定しておくことで、簡単に不透明のグループと半透明のグループに分けることができます。

設定の手間はあるものの、方法`2`のほうが効率的なため、本テキストでは方法`2`を採用することにしました。そして、不透明と半透明の設定は「半透明用のレンダーキュー」を追加することで対応します。

追加するレンダーキューの名前は`transparent`(トランスペアレント、「透明な」「透き通った」という意味)とします。`GameObject.h`を開き、`RenderQueue`列挙型に半透明モデル用のメンバを追加してください。

```diff
 enum RenderQueue
 {
   RenderQueue_geometry = 2000, // 一般的な図形
+  RenderQueue_transparent = 3000, // 半透明な図形
   RenderQueue_overlay  = 4000, // UI, 全画面エフェクトなど
   RenderQueue_max      = 5000, // キューの最大値
```

それでは、グレアオブジェクトのレンダーキューを設定しましょう。`FluorescentLight.h`を開き、グレアを設定するプログラムに次のプログラムを追加してください。

```diff
     // ぼんやりとした光を追加
     auto glare = engine->Create<GameObject>("glare", owner->position);
     glare->position.y -= 0.25f; // いいかんじ見えるように位置を調整
+    glare->renderQueue = RenderQueue_transparent; // 半透明として扱う
     glare->meshId = MeshId_plane_xy;
     glare->texColor = std::make_shared<Texture>("Res/glare.tga");
```

プログラムが書けたらビルドして実行してください。表示がおかしくならず、蛍光灯の周囲がほんのり明るくなっていたら成功です。

<p align="center">
<img src="images/11_result_4_color_buffer.jpg" width="45%"/>
</p>

ビルボードの特徴は「常にカメラの方を向く」ことです。今回はこの特徴を利用して、「光が周囲の塵やホコリに反射して空間がぼんやりと明るくなる様子」を表現しました。

実際に、ビルボードは「境界のはっきりしない光や煙、炎などを表現する手段」として、多くのゲームで利用されます。

### 2.6 深度バッファへの書き込みを禁止する

「半透明用のレンダーキュー」を追加したことで、半透明と不透明の描画を分離できるようになりました。ただ、これだけでは半透明な図形同士で同じ問題が起きてしまいます。

ゲームを起動したら迷路を少し進んで、最初の敵が登場する部屋に入ってください。この部屋には2つの蛍光灯が配置してありますが、部屋の右側から左を見たときにビルボードの見え方がおかしくなっています。

このときの深度バッファは以下のような状態になっていて、手前のビルボードが奥のビルボードを隠してしまっていることが分かります。

<p align="center">
<img src="images/11_result_5_color_buffer.jpg" width="45%"/>&emsp;<img src="images/11_result_5_depth_buffer.png" width="45%"/><br>
[左=奥のグレアが不自然に切れている 右=深度バッファにビルボードが描画されている]
</p>

このような半透明オブジェクト同士の描画では、レンダーキューによって描画順を制御するだけでは対処できないため、別の対策を併用しなくてはなりません。

半透明オブジェクトの問題は「半透明なので奥のオブジェクトが透けて見える」ことです。しかし、これは「手前のオブジェクトが奥のオブジェクトを隠すことは出来ない」ことも意味します。

つまり、半透明オブジェクト同士では深度バッファを使う意味がないわけです。しかし、不透明オブジェクトに対しては、依然として深度テストが必要です。

そこで、「深度テストは行うが、深度バッファへの書き込みは禁止する」ように設定します。こうすることで、不透明オブジェクトとの前後関係を正しく処理しつつ、半透明オブジェクトがお互いを隠すことはなくなります。

深度バッファへの書き込み禁止する範囲は、`transparent`キューから`overlay`キューのあいだです。そこで、`Engine`クラスの描画処理に、`transparent`から`overlay`までの範囲を描画する処理を追加します。

`Engine.cpp`を開き、`Render`メンバ関数の定義に次のプログラムを追加してください。

```diff
   std::stable_sort(gameObjects.begin(), gameObjects.end(),
     [](const GameObjectPtr& a, const GameObjectPtr& b) {
       return a->renderQueue < b->renderQueue; });
+
+  // transparentキューの先頭を検索
+  const auto transparentBegin = std::lower_bound(
+    gameObjects.begin(), gameObjects.end(), RenderQueue_transparent,
+    [](const GameObjectPtr& e, int value) { return e->renderQueue < value; });

   // overlayキューの先頭を検索
   const auto overlayBegin = std::lower_bound(
-    gameObjects.begin(), gameObjects.end(), RenderQueue_overlay,
+    transparentBegin, gameObjects.end(), RenderQueue_overlay,
     [](const GameObjectPtr& e, int value) { return e->renderQueue < value; });

-  // overlay以前のキューを描画
-  DrawGameObject(gameObjects.begin(), overlayBegin);
+  // transparent以前のキューを描画
+  DrawGameObject(gameObjects.begin(), transparentBegin);
+
+  // transparentからoverlayまでのキューを描画
+  glDepthMask(GL_FALSE); // 深度バッファへの書き込みを禁止
+  DrawGameObject(transparentBegin, overlayBegin);
+  glDepthMask(GL_TRUE); // 深度バッファへの書き込みを許可

   // overlay以降のキューを描画
   glDisable(GL_DEPTH_TEST); // 深度テストを無効化
```

深度バッファへの書き込みを禁止、または許可するには`glDepthMask`(ジーエル・デプス・マスク)関数を使います。

<p><code class="tnmai_code"><strong>【書式】</strong><br>
void glDepthMask(GLboolean flag);
</code></p>

`flag`引数に`GL_TRUE`を指定すると、深度バッファへの書き込みが「許可」されます。
`GL_FALSE`を指定すると、深度バッファへの書き込みが「禁止」されます。

また、今回は使いませんが、`glColorMask`(ジーエル・カラー・マスク)関数を使うとカラーバッファへの書き込みを制御できます。

<p><code class="tnmai_code"><strong>【書式】</strong><br>
void glColorhMask(
  GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
</code></p>

カラーバッファは「赤、緑、青、アルファ」の4要素で構成されるため、`glColorMask`関数は「要素ごとに書き込みの許可と禁止を選択できる」ようになっています。

プログラムが書けたらビルドして実行してください。部屋の右側から左を見ても、左側から右を見ても、奥側のグレアが正しく描画されていたら成功です。

<p align="center">
<img src="images/11_result_6_color_buffer.jpg" width="45%"/>&emsp;<img src="images/11_result_6_depth_buffer.png" width="45%"/><br>
[左=奥のグレアが正しく描画されている 右=深度バッファにビルボードが描画されていない]
</p>

### 2.7 乱数生成機能を追加する

ビルボードは輪郭のはっきりしない光や炎、煙などの表現に向いています。そこで、床にホコリか霧のようなエフェクトを表示してみようと思います。

霧の仕様は以下のようにします。

>1. 霧オブジェクトは事前に決められた範囲に発生する。
>2. 一定時間ごとに、範囲内のランダムな位置に霧オブジェクトがひとつ発生する。
>3. 霧オブジェクトは発生後一定時間で消える。

この仕様を踏まえて、霧自体を制御する「霧コンポーネント」と、霧を発生させる「霧ジェネレーターコンポーネント」の2種類を定義することにします。

霧は英語で`mist`(ミスト)というので、霧コンポーネントの名前は`Mist`とします。そして、霧ジェネレーターコンポーネントの名前は`MistGenerator`とします。

それはいいのですが、霧の仕様で気になるのは「範囲内のランダムな位置煮切りオブジェクトがひとつ発生する」という部分です。つまり「乱数を生成する機能」が必要ということです。

そこで、霧コンポーネントの前に「乱数生成機能」を作ることにします。プロジェクトの
`Src/Engine`フォルダに`Random.h`という名前のヘッダファイルを追加してください。

追加したファイルを開き、次のプログラムを追加してください。

```diff
+/**
+* @file Random.h
+*/
+#ifndef RANDOM_H_INCLUDED
+#define RANDOM_H_INCLUDED
+
+/**
+* 乱数生成機能を格納する名前空間
+*/
+namespace Random {
+
+/**
+* 乱数を初期化する
+*
+* @param seed 乱数の種
+*/
+void Initialize(int seed);
+
+/**
+* 0.0～1.0の範囲の一様乱数を取得する
+*
+* @return 生成した乱数
+*/
+float Value();
+
+/**
+* 指定されたの範囲の一様乱数を取得する
+*
+* @param min 生成範囲の最小値
+* @param max 生成範囲の最大値
+*
+* @return 生成した乱数
+*/
+float Range(float min, float max);
+
+} // namespace Random
+
+#endif // RANDOM_H_INCLUDED
```

次に、プロジェクトの`Src/Engine`フォルダに`Random.cpp`という名前のCPPファイルを追加してください。追加したファイルを開き、次のプログラムを追加してください。

```diff
+/**
+* @file Random.cpp
+*/
+#include "Random.h"
+#include <random>
+
+namespace Random {
+
+// 乱数生成オブジェクト
+std::random_device rd;
+std::mt19937 randomEngine(rd());
+
+void Initialize(int seed)
+{
+  randomEngine.seed(seed);
+}
+
+float Value()
+{
+  return std::uniform_real_distribution<float>(0, 1)(randomEngine);
+}
+
+float Range(float min, float max)
+{
+  return std::uniform_real_distribution<float>(min, max)(randomEngine);
+}
+
+} // namespace Random
```

C++11以降のC++では、いくつかの乱数生成クラスが選べるようになっています。2023年時点で主に使われているのは`mt19937`(エムティ・いちきゅうきゅうさんなな)というクラスです。

`mt19937`は「メルセンヌ・ツイスター」というアルゴリズムを使っており、同じパターンが繰り返えされる周期が非常に長いという特徴があります。

C言語の`rand`関数と同様に、`mt19937`も適切に初期化しないと毎回同じ値が同じ順番で返されます。これを防ぐには、コンストラクタ引数に「シード(種)」と呼ばれる値を指定します。

<p><code class="tnmai_code"><strong>【書式】</strong><br>
mt19937(シード);
</code></p>

ただ、毎回同じシードを指定すると、結局同じ値が返されることになります。そこで、プログラムが実行されるたびにシードを変えなくてはなりません。

C++03までは、シードとして`time`関数が返す「現在の時刻」を利用していました。しかし、C++11以降は`random_device`(ランダム・デバイス)クラスを使うことが多いです。

`time`が使われなくなったのは、「`time`で初期化すると、実行開始時刻から乱数列が予測できてしまう」ためです。

`random_device`は乱数生成クラスのひとつで、「<ruby>真<rt>しん</rt></ruby>の乱数」を返します。ここでいう「真の」とは、「常に予測不能である」という意味です。

「真の乱数」を実現するために、`random_device`は「ハードウェアが発するノイズや、キーボード、マウスの動き」といった要素から乱数を生成します。これにより、外部からシードを予測できなくなります。

#### 【ディストリビューションクラスによる乱数範囲の制御】

乱数生成クラス自体は範囲指定の機能を持ちません。指定した範囲の一様乱数を取得するには
`uniform_real_distribution`(ユニフォーム・リアル・ディストリビューション)クラスを使います。

`uniform`(ユニフォーム)は「一様(いちよう)な」、`real`(リアル)は「実数の」、
`distribution`(ディストリビューション)は「分布」という意味で、「一様な実数の分布」という意味の名前になっています。

>なお、C++の乱数ライブラリにおける「実数」とは「浮動小数点数」のことです(つまり`float`や`double`)。

`uniform_real_distribution`クラスは、コンストラクタで最小値と最大値を指定します。

<p><code class="tnmai_code"><strong>【書式】</strong><br>
template<typename T>
uniform_real_distribution<T>(最小値, 最大値);
</code></p>

乱数を生成するときは、関数呼び出し演算子に乱数生成クラスのオブジェクトを指定します。<br>
すると、コンストラクタで指定した範囲の乱数が返される、という仕組みになっています。

<p><code class="tnmai_code"><strong>【書式】</strong><br>
T uniform_real_distribution::operator()(乱数生成オブジェクト);
</code></p>

### 2.8 霧コンポーネントを定義する

霧コンポーネントの作成に戻りましょう。まず、霧の画像を用意します。

<pre class="tnmai_assignment">
<strong>【課題10】</strong>
以下のURLから<code>mist.png</code>(ミスト)画像をダウンロードし、TGA形式に変換して、プロジェクトの<code>Res</code>フォルダに保存しなさい。
`https://github.com/tn-mai/OpenGL3D2023/blob/main/res/mist.png`
</pre>

霧コンポーネントと霧ジェネレーターコンポーネントは、まとめて`Mist.h`というファイルに定義することにします。これらのコンポーネントを個別に使うとは考えにくいので、分ける必然性がないからです。

プロジェクトの`Src`フォルダに`Mist.h`という名前のヘッダファイルを追加してください。追加したファイルを開き、次のプログラムを追加してください。

```diff
+/**
+* @file Mist.h
+*/
+#ifndef MIST_H_INCLUDED
+#define MIST_H_INCLUDED
+#include "Engine/Component.h"
+#include "Engine/GameObject.h"
+#include "Engine/Billboard.h"
+#include "Engine/Random.h"
+#include "Engine/Engine.h"
+
+/**
+* 霧コンポーネント
+*/
+class Mist : public Component
+{
+  friend class MistGenerator;
+
+public:
+  Mist() = default;
+  virtual ~Mist() = default;
+
+  virtual void Update(float deltaTime) override
+  {
+    // タイマーが寿命を超えたら自身を削除
+    timer += deltaTime;
+    if (timer >= lifespan) {
+      GetOwner()->Destroy();
+    }
+  }
+
+private:
+  float timer = 0;    // 経過時間タイマー
+  float lifespan = 7; // 寿命(秒)
+};
+
+#endif // MIST_H_INCLUDED
```

次に「霧ジェネレーターコンポーネント」を定義します。霧コンポーネントの定義の下に、次のプログラムを追加してください。

```diff
   float timer = 0;    // 経過時間タイマー
   float lifespan = 7; // 寿命(秒)
 };
+
+/**
+* 霧を発生させるコンポーネント
+*/
+class MistGenerator : public Component
+{
+public:
+  MistGenerator() = default;
+  virtual ~MistGenerator() = default;
+
+  virtual void Update(float deltaTime) override
+  {
+    timer += deltaTime;
+    if (timer < interval) {
+      return;
+    }
+    timer -= interval;
+
+    auto owner = GetOwner();
+    auto engine = owner->GetEngine();
+
+    // 霧を発生させる位置をランダムに選択
+    vec3 pos = owner->position;
+    pos.x += Random::Range(-range.x, range.x);
+    pos.y += 0.15f; // いいかんじに表示されるように高さを調整
+    pos.z += Random::Range(-range.y, range.y);
+
+    // 霧を生成
+    auto mist = engine->Create<GameObject>("mist", pos);
+    mist->meshId = MeshId_plane_xy;
+    mist->texColor = texMist;
+    mist->renderQueue = RenderQueue_transparent;
+    mist->AddComponent<Billboard>();
+    mist->AddComponent<Mist>();
+  }
+
+  vec2 range = { 1, 1 }; // XZ方向の発生半径
+  float interval = 1;    // 霧を発生する間隔
+
+private:
+  // 霧テクスチャ
+  TexturePtr texMist =
+    std::make_shared<Texture>("Res/mist.tga");
+  float timer = 0; // 霧発生タイマー
+};

 #endif // MIST_H_INCLUDED
```

### 2.9 マップに霧ジェネレータを配置する

次に、マップデータに霧ジェネレータを表すデータを追加します。`maze00.txt`を開き、次のテキストを追加してください。

```diff
 ライト		蛍光灯	3	4	90
 ライト		蛍光灯	2.5	6.5	90
 ライト		蛍光灯	3.5	6.5	90
+霧			3x2		2	1.5	0
```

霧ジェネレータの座標は、マップに合わせて変更してください。名前に指定した`3x2`(さん・エックス・に)というのは、霧を発生させる範囲(m)を表しています。

続いて、マップデータから霧ジェネレータを作成するプログラムを追加します。<br>
まずは`MainGameScene.cpp`を開き、`Mist.h`をインクルードしてください。

```diff
 #include "RemoteDoor.h"
 #include "EnemySkull.h"
 #include "FluorescentLight.h"
+#include "Mist.h"
 #include "TitleScene.h"
 #include "Engine/UIButton.h"
```

次に`Initialize`メンバ関数に次のプログラムを追加してください。

```diff
         light->AddComponent<FluorescentLight>();
       }
     }
+    // 霧ジェネレータを作成
+    else if (strcmp(type, u8"霧") == 0) {
+      vec2 range;
+      if (sscanf(name, "%fx%f", &range.x, &range.y) == 2) {
+        auto mistGenerator = engine.Create<GameObject>(name, pos);
+        auto mistGen = mistGenerator->AddComponent<MistGenerator>();
+        mistGen->range = range;
+      }
+    }
  } // while

   // 床を作成
```

プログラムが書けたらビルドして実行してください。部屋の床に霧エフェクトが表示されたら成功です。

<pre class="tnmai_assignment">
<strong>【課題11】</strong>
霧オブジェクトのアルファ値を「透明→不透明→透明」の順で徐々に変化させなさい。
</pre>

<pre class="tnmai_assignment">
<strong>【課題12】</strong>
霧オブジェクトごとにサイズが変わるように、Xスケールを0.2～0.5の範囲で、Yスケールを0.1～0.2の範囲でランダムに選択するようにしなさい。
</pre>

<p align="center">
<img src="images/11_result_7.jpg" width="45%"/><br>
[床に霧エフェクトが表示されている]
</p>

>**【2章のまとめ】**
>
>* ビルボードの「常にカメラの方を向く」、輪郭のはっきりしない光や煙、炎のような半透明の物体を表現することができる。
>* 不透明モデルと半透明モデルの両方を適切に描画するには、先に不透明モデルを描画し、その後で半透明モデルを描画する。
>* 半透明モデル同士の描画を正しく処理するには、「深度バッファへの書き込みを禁止する」という方法がある。
>* 乱数を生成するには`mt19937`クラスを使う。指定した範囲の乱数を作るには、<br>`uniform_real_distribution`クラスを組み合わせて使う。

<div style="page-break-after: always"></div>

## 3. 音声再生

### 3.1 音声ライブラリを追加する

ゲームは、プレイヤーへのフィードバックの多くの部分を音声に頼っています。まるで本物のような映像を作り出せたとしても、それだけではプレイヤーを没入させるのは難しいものです。

例としてテレビ番組を考えてみましょう。みなさんがテレビ番組を見る時、音声は当然スピーカーから再生されています。しかし、みなさんの感覚では、画面の中の人物の口元から発声されているかのように感じていると思います。

これは、人間にとって聴覚よりも視覚が優先的な情報源であるからこそ起こる現象です。一方で、音量を0にして番組を視聴すると、番組の内容がほとんど分からなくなってしまいます(環境映像のようなものは除いて)。

これらのことは、人間の情報伝達において、聴覚がいかに重要であるかを示しています。そして、音声の重要性は、ゲームにおいても変わりません。そこで、プロジェクトに音声ライブラリを追加して、音声を再生できるようにしましょう。

<pre class="tnmai_assignment">
<strong>【課題13】</strong>
ブラウザで以下のURLを開き、音声ライブラリのZIPファイルをダウンロードしなさい。
  <code>https://github.com/tn-mai/OpenGL3D2023/blob/main/doc/EasyAudio.zip</code>

EasyAudio.zipファイルには、以下の2つのファイルが格納されています。
 - EasyAudio.cpp
 - EasyAudio.h

プロジェクトの<code>Src/Engine</code>フォルダ内に<code>EasyAudio</code>フォルダを作成し、その中に上記の2つのファイルをコピーしなさい。
</pre>

音声ライブラリのファイルをコピーしたら、Visual Studioのソリューションエクスプローラーにある「ソースファイル」フィルタを右クリックして「追加→既存の項目」を選択します。そして、先程コピーした2つのファイルをプロジェクトに追加してください。

これで音声ライブラリが追加されました。

### 3.2 音声ライブラリの処理を追加する

`EasyAudio`クラスで音声を再生するには、「ライブラリの初期化」、「ライブラリの更新」、「ライブラリの終了」という3つの関数を呼び出す必要があります。

その前に、ヘッダファイルをインクルードしましょう。<br>
`Engine.cpp`を開き、`EasyAudio.h`をインクルードしてください。

```diff
 * @file Engine.cpp
 */
 #include "Engine.h"
+#include "EasyAudio/EasyAudio.h"

 #pragma warning(push)
 #pragma warning(disable:4005)
```

次に、`Run`メンバ関数の定義に次のプログラムを追加してください。

```diff
   if (result) {
     return result;
   }
+
+  // 音声ライブラリを初期化
+  if ( ! EasyAudio::Initialize()) {
+    return 1; // 初期化失敗
+  }

   while (!glfwWindowShouldClose(window)) {
     Update();
     Render();
     RemoveDestroyedGameObject();

+    // 音声ライブラリを更新
+    EasyAudio::Update();
   }
+
+  // 音声ライブラリを終了
+  EasyAudio::Finalize();

   glfwTerminate();
   return 0;
```

これで、音声を再生できるようになりました。

### 3.3 音声を用意する

音声ライブラリだけでは音声を再生することはできません。なぜなら、音声ファイルが必要だからです。

ということで、適当にゲームで使う音声を都合しなくてはなりません。とりあえず以下の表にある音声を用意してください。

| 分類   | 音声の用途 |
|:------:|:-----|
| BGM    | タイトル画面のBGM |
| BGM    | ゲームプレイ中のBGM |
| 効果音 | ボタンをクリックしたときの効果音 |
| 効果音 | ドアが開くときの効果音 |
| 効果音 | レバーが動くときの効果音 |
| 効果音 | ゴールに到達したとき(ゲームクリア)の効果音 |
| 効果音 | 敵につかまったとき(ゲームオーバー)の効果音 |

>**【音声ライブラリで再生可能な形式】**<br>
>`WAV`, `MP3`, `AAC`, `WMA`に対応しています。`OGG`などには対応していません。<br>
>また、ビットレートの高いMP3は再生できないことが多いです。MP3が再生されない場合は、変換ツール(`MP3 変換 オンライン`等で検索)でビットレートを128kbpsにすると、再生できる可能性があります。

<pre class="tnmai_assignment">
<strong>【課題14】</strong>
プロジェクトの<code>Res</code>フォルダに<code>Audio</code>というフォルダを作成しなさい。
次に、上の表にある用途に適した音声ファイルを、適当なサイトからダウンロードし(自分で作成してもよいでしょう)、<code>Audio</code>フォルダに配置しなさい。

重要: 著作権表記用のテキストファイルを作成し、ダウンロードしたすべての音声について著作権表記を行うこと。
</pre>

>**【フリーのサウンドデータを公開しているサイトについて】**<br>
>音声(に限りませんが)は、ゲーム内容に合っていて、かつ他ではあまり使われていないものを選ぶべきです。就職作品を審査する人々は同じような作品をいくつも見ているため、みんなが使うような音声は聞き飽きているからです。特に、国内で有名な個人サイトの音声などは聞き飽きていると考えてください。
>
>おすすめの方法は、「投稿型サイト」または「国外のサイト」を利用することです。`dova-s.jp`や`soundcloud.com`のような投稿型サイトはファイル数が多いので、他人と同じ音声を使う可能性がかなり低くなります。国外のサイトは「英語で書かれている」ために日本からの利用者が少ないので、国内の他の就職作品と同じ音声になる可能性が低いです。
>
>以下に、高品質なフリーのサウンドデータを公開しているサイトをいくつか挙げておきます。これらのサイトからダウンロードしたファイルは、音声作業用フォルダを作り、さらにサイト名をつけたサブフォルダを作って、そのなかにまとめておくとよいでしょう。
>
>\[BGM(投稿型サイト)\]
>
>* `dova-s.jp`: 国内では最大規模の投稿型サイト。ゲーム用を想定した音声ファイルも数多く投稿されています。大量の音声ファイルがあるので、まず重複することはないでしょう。
>* `soundcloud.com`: 世界最大規模の音楽投稿型サイト。有料、無料を見分けにくいうえにボーカルありとなしが混在しているため、BGMの検索には慣れが必要です。しかし、圧倒的な投稿数はそれを補ってあまりあるほど魅力的です。
>
>\[BGM(海外の個人サイト)\]
>
>* `soundimage.org`: Eric Matyas(エリック・マティアス)氏のサイト。ゲーム開発者向けの無料の音楽や効果音、テクスチャなどが公開されています。右のリストから好きなジャンルを選んで音楽を探してください。プレイヤーの下に表示される曲名を右クリックしてダウンロードします。
>* `incompetech.filmmusic.io`: Kevin MacLeod(ケビン・マクロード)氏のサイト。映画やゲーム向けの無料の音楽が公開されています。左の`Search`(サーチ)または`Genres`(ジャンル)を選んで音楽を探してください。
>* `bensound.com`: Benjamin Tissot(ベンジャミン・ティソ)氏のサイト。映画やゲーム向けの無料の音楽が公開されています。`DOWNLOAD`(ダウンロード)と表示されているのが無料の音楽です。
>
>\[効果音\]
>
>* `www.fesliyanstudios.com`: David Fesliyan(デイビッド・フェスリアン)氏の個人サイトで、映画やゲーム向けの音楽と効果音が公開されています。
>* `freesound.org`: スペインのポンペウ・ファブラ大学の音楽技術グループが管理運営している音声投稿サイトです。23万を超える大量の音声が投稿されています。品質にバラつきはありますが、大抵の効果音が見つかります。
>
>\[オンラインで効果音を作成できるサイト\]
>
>* `sfbgames.itch.io/chiptone`: レトロゲーム風の効果音を生成できます。エフェクターを調整すると音色を調整できますが、少し扱いが難しいです。オフラインで使えるダウンロード版があります。効果音を保存するには、右側にある黒い「SAVE .WAV」ボタンを押します。
>* `sfxr.me`: レトロゲーム風の効果音を生成できるサイトです。左のプリセットボタンをクリックするとランダムな効果音が作成されます。右側の青字で書かれたWAVファイルを右クリックしてダウンロードします。
>* `www.leshylabs.com/apps/sfMaker`: こちらもレトロゲーム風の効果音を生成してくれるサイトです。左のプリセットボタンをクリックするとランダムな効果音が作れます。右側の`Save Wave`ボタンからダウンロードします。

<div style="page-break-after: always"></div>

### 3.4 音声定義ファイルを追加する

音声を再生するときは「音声ファイル名」を指定します。ただ、プログラム中に直接ファイル名を書くのはおすすめできません。同じ音声を再生するたびにファイル名を書くのは非効率ですし、打ち間違える可能性が増えるからです。

例えば「ボタンクリックの効果音」用に`button_click.wav`という名前の音声ファイルがあるとしましょう。ゲームではいろんなものを爆発させるので、コードのあちこちに`button_click.wav`と書くことになります。

2, 3カ所程度ならともかく、何度も何度も書いていると、`bottun_click.wav`や`buttonclick.wav`のように<ruby>綴<rt>つづ</rt></ruby>りを間違える可能性が高まります。その結果、音声がならなかったり、間違った音声が再生されたりすることになります。

このような間違いを防ぐには、音声ファイル名を示す「定数」を定義して、ファイル名の代わりに定数を使います。定数には入力補完が働きますし、名前を間違えるとコンパイルエラーになるのですぐ分かります。

>定数を使っても「別の定数名を書いてしまう」という間違いは検出できませんが、他のミスは防げるので十分に意味はあります。

プロジェクトの`Src`フォルダに`AudioSettings.h`(オーディオ・セッティングス)という名前のヘッダファイルを追加してください。追加した`AudioSettings.h`を開き、次のプログラムを追加してください。

```diff
+/**
+* @file AudioSettings.h
+*/
+#ifndef AUDIOSETTINGS_H_INCLUDED
+#define AUDIOSETTINGS_H_INCLUDED
+
+/**
+* 音声再生プレイヤー番号
+*/
+namespace AudioPlayer {
+inline constexpr int bgm = 0; // BGMの再生に使うプレイヤー番号
+} // namespace Player
+
+/**
+* BGM設定
+*/
+namespace BGM {
+inline constexpr char title[] = "Res/Audio/????"; // タイトル画面のBGM
+inline constexpr char mainGame[] = "Res/Audio/????"; // 迷路のBGM
+} // namespace Bgm
+
+/**
+* 効果音設定
+*/
+namespace SE {
+inline constexpr char buttonClick[] = "Res/Audio/????"; // ボタンクリック音
+inline constexpr char doorOpen[] = "Res/Audio/????";  // ドアが開く音
+inline constexpr char leverMove[] = "Res/Audio/????"; // レバーの動作音
+inline constexpr char goalEvent[] = "Res/Audio/????"; // ゴールに到達した
+inline constexpr char gameOverEvent[] = "Res/Audio/????"; // 敵につかまった
+} // namespace SE
+
+#endif // AUDIOSETTINGS_H_INCLUDED
```

ヘッダファイルに変数や定数を定義すると、インクルード先のCPPファイルごとにコピーが作られます。インクルードしているCPPファイルがたくさんあると大量のコピーが作られるため、実行ファイルのサイズが肥大化する可能性があります。

実行ファイルが肥大化するとプログラムの性能に影響します。これを解決するには`inline`(インライン)キーワードを使います。

>`inline`はもともとは関数にのみ指定できたのですが、C++17において変数にも指定できるように改良されました。

`inline`の作用のひとつに「定義をひとつに保つ」というものがあります。この作用により、変数を`inline`指定するとコピーが作られなくなります。

これが、`inline constexpr`という宣言の意味です。「C++14以前を使っている」、「チームのコーディングルールで決まっている」などの理由がない限り、定数は`inline constexpr`で定義するとよいでしょう。

>**【constexpr関数とconstexprメンバ変数は勝手にinlineになる】**<br>
>関数またはメンバ変数に`constexpr`を指定すると、自動的に`inline`扱いになります。つまり、`inline`が必要なのはグローバルな「定数」を定義するときだけです。

<pre class="tnmai_assignment">
<strong>【課題15】</strong>
<code>AudioSettings.h</code>にある<code>????</code>の部分を、ダウンロードまたは作成した音声ファイル名に置き換えなさい。
</pre>

### 3.5 BGMを再生する

それでは音声を再生しましょう。`TitleScene.cpp`を開き、音声用ヘッダファイルをインクルードしてください。

```diff
 #include "Engine/UILayout.h"
 #include "Engine/UIButton.h"
 #include "Engine/Engine.h"
+#include "Engine/EasyAudio/EasyAudio.h"
+#include "AudioSettings.h"
 
 /**
 * タイトル画面を初期化する
```

次に、`Initialize`メンバ関数の定義にあるUI設定コードの下に、次のプログラムを追加してください。

```diff
   fadeObject->scale = {fbSize.x / fbSize.y, 1, 1};
   // カラーを「黒、透明」に設定
   std::fill_n(fadeObject->color, 4, 0.0f);
+
+  // BGMを再生
+  EasyAudio::Play(AudioPlayer::bgm, BGM::title, 1, true);

   return true; // 初期化成功
```

`Play`(プレイ)関数は、BGMのようにループ再生をしたり、途中で停止させる必要のある音声を再生する場合に使います。

<pre class="tnmai_code"><strong>【書式】</strong>
void Play(再生に使うプレイヤー番号, 音声ファイル名, 音量, ループフラグ);
</pre>

プログラムが書けたらビルドして実行してください。タイトル画面でBGMが再生されていたら成功です。

### 3.6 効果音(SE)を再生する

次は効果音を再生しましょう。`startButton`のデリゲートを設定するプログラムに、次のプログラムを追加してください。

```diff
     [this](UIButton* button) {
       fadeTimer = 1;
       button->interactable = false; // ボタンを無効化
+      EasyAudio::PlayOneShot(SE::buttonClick);
     });

   // フェードアウト用UIオブジェクト
```

効果音のようにループや途中停止などが必要ない音声の場合、`PlayOneShot`(プレイ・ワン・ショット)関数を使います。

<pre class="tnmai_code"><strong>【書式】</strong>
void PlayOneShot(音声ファイル名, 音量);
</pre>

プログラムが書けたらビルドして実行してください。スタートボタンをクリックしたときに効果音が再生されたら成功です。

### 1.7 BGMを停止する

現在は、ゲームが開始されてもタイトル画面のBGMが鳴り続けています。タイトル画面が終了するときにBGMを止めましょう。`Finalize`メンバ関数の定義に次のプログラムを追加してください。

```diff
 void TitleScene::Finalize(Engine& engine)
 {
   engine.ClearGameObjectAll();
+  EasyAudio::Stop(AudioPlayer::bgm);
 }
```

プログラムが書けたらビルドして実行してください。スタートボタンをクリックしてゲームを開始したとき、BGMが停止していたら成功です。

<pre class="tnmai_assignment">
<strong>【課題16】</strong>
メインゲーム画面の<code>Initialize</code>メンバ関数に、メインゲーム画面用のBGMを再生するプログラムを追加しなさい。
</pre>

<pre class="tnmai_assignment">
<strong>【課題17】</strong>
以下の効果音を再生するプログラムを追加しなさい。

- ドアが開くときに<code>SE::doorOpen</code>を再生する。
- <code>SimpleLever</code>コンポーネントのレバーがクリックされたとき、
  <code>SE::leverMove</code>を再生する。
- ゲームクリア時にBGMを停止し、<code>SE::goalEvent</code>を再生する。
- ゲームオーバー時にBGMを停止し、<code>SE::gameOverEvent</code>を再生する。
- ゲームクリアおよびゲームオーバーにおいて、
  「戻るボタン」をクリックしたときに<code>SE::buttonClick</code>を再生する。
</pre>

>**【3章のまとめ】**
>
>* 音声を選ぶときは「ゲームの雰囲気に合うこと」を重視する。
>* 効果音ジェネレーターを使うと、簡単な効果音なら自分で作ることができる。
